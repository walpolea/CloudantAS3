package com.andrewwalpole.cloudantas3 {	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.net.URLRequestMethod;	import flash.events.Event;	import flash.net.URLRequestHeader;	import com.sociodox.utils.Base64;	import flash.utils.ByteArray;	import flash.events.IOErrorEvent;	import flash.events.EventDispatcher;	import flash.net.URLVariables;		//This library requires com.sociodox.utils.Base64 which can be found in ./lib/Base64.swc	//make sure you add it to your project	public class CloudantAS3 extends EventDispatcher {		private const ALL_DOCS:String = "_all_docs";		private const BULK_DOCS:String = "_bulk_docs";		private var apikey:String;		private var serverURL:String;		private var DB:String;		public function CloudantAS3( surl:String, db:String, uname:String, pwd:String ) {						setServerURL( surl );			setDB( db );			setCredentials( uname, pwd );					}				public function setCredentials( uname:String, pwd:String ):void {			var ba:ByteArray = new ByteArray();			ba.writeUTFBytes(uname+":"+pwd);			apikey = Base64.encode( ba );		}				public function setDB( db:String ):void {			DB = db;						if( DB.charAt( DB.length-1 ) != "/" ) {				DB = DB + "/";			}					}				public function setServerURL( surl:String ):void {			serverURL = surl;						if( serverURL.charAt( serverURL.length-1 ) != "/" ) {				serverURL = serverURL + "/";			}		}				//Write a document to your database.		//if the document already has a current rev it will update the existing document		public function write( doc:CloudantDoc ):void {						var ul:URLLoader = new URLLoader();			ul.addEventListener( Event.COMPLETE, onWriteResponse );						ul.addEventListener(IOErrorEvent.IO_ERROR, onIOError);						var req:URLRequest = new URLRequest( serverURL + DB );			req.method = URLRequestMethod.POST;			req.contentType = "application/json";			req.data = doc.toString();						trace("writing: ", doc.toString() );						var credsHeader:URLRequestHeader = new URLRequestHeader( "Authorization", "Basic " + apikey );			req.requestHeaders.push(credsHeader);						ul.load( req );		}				//Write multiple documents into your db at once		//see https://cloudant.com/for-developers/crud/#curl-bulk for details		public function writeBulk( docs:Vector.<CloudantDoc> ):void {						var bulkdocs:Object = { docs: [] };						for( var i:int = 0; i < docs.length; i++ ) {				bulkdocs.docs.push( docs[i].toObject() );			}						var ul:URLLoader = new URLLoader();			ul.addEventListener( Event.COMPLETE, onWriteBulkResponse );						ul.addEventListener(IOErrorEvent.IO_ERROR, onIOError);						var req:URLRequest = new URLRequest( serverURL + DB + "/" + BULK_DOCS );			req.method = URLRequestMethod.POST;			req.contentType = "application/json";			req.data = JSON.stringify(bulkdocs);						trace("writing: ", JSON.stringify(bulkdocs) );						var credsHeader:URLRequestHeader = new URLRequestHeader( "Authorization", "Basic " + apikey );			req.requestHeaders.push(credsHeader);						ul.load( req );		}				public function read( docID:String ):void {						var ul:URLLoader = new URLLoader();			ul.addEventListener( Event.COMPLETE, onReadResponse );			ul.addEventListener(IOErrorEvent.IO_ERROR, onIOError);						var req:URLRequest = new URLRequest( serverURL + DB + docID );			req.method = URLRequestMethod.POST;			req.contentType = "application/json";			req.data = "";						var credsHeader:URLRequestHeader = new URLRequestHeader( "Authorization", "Basic " + apikey );			req.requestHeaders.push(credsHeader);						ul.load( req );		}				public function update( doc:CloudantDoc ):void {			if( doc._rev ) {				write( doc );			}		}				public function queryPrimaryIndex( params:Object, include_docs:Boolean = true ):void {						var ul:URLLoader = new URLLoader();			ul.addEventListener( Event.COMPLETE, onQueryResponse );			ul.addEventListener(IOErrorEvent.IO_ERROR, onIOError);						var url:String = serverURL + DB + ALL_DOCS + "?";						if( params.limit ) {				url += 'limit='+params.limit+'&';			}						if( params.skip ) {				url += 'skip='+params.skip+'&';			}						if( params.startkey && params.endkey ) {				url += 'startkey="'+params.startkey+'"&endkey="'+params.endkey+'"&';								if( params.inclusive_end ) {					url += "inclusive_end="+params.inclusive_end+"&";				}			}						if( params.key ) {				url += 'key="'+params.key+'"&';			}						if( include_docs ) {				url += "include_docs=true";			} else {				url += "include_docs=false";			}						if( url.charAt( url.length-1 ) == "&" ) {				url = url.substr( 0, url.length-1 );			}						var req:URLRequest = new URLRequest( url );			if( params.keys ) {				req.data = JSON.stringify({ keys:params.keys });			} else {				req.data = "";			}						req.method = URLRequestMethod.POST;			req.contentType = "application/json";						var credsHeader:URLRequestHeader = new URLRequestHeader( "Authorization", "Basic " + apikey );			req.requestHeaders.push(credsHeader);						ul.load( req );		}				private function onWriteResponse( e:Event ):void {						var raw:String = e.target.data;			var resp:Object = JSON.parse( e.target.data );						trace( raw );						if( resp.ok === false ) {								this.dispatchEvent( new CloudantEvent( CloudantEvent.WRITE_ERROR, resp, raw ) );			} else if( resp.ok === true ) {								//delete "ok", we don't want the person taking the response and turning it back 				//into a doc only to find they added "ok" prop as data to the document				delete resp.ok;								this.dispatchEvent( new CloudantEvent( CloudantEvent.WRITE_COMPLETE, resp, raw ) );							}					}				private function onWriteBulkResponse( e:Event ):void {						var raw:String = e.target.data;			var resp:Object = JSON.parse( e.target.data );						//Bulk responses don't return an "ok" property, so I'm not entirely sure what to do...			//I want to handle a bulk the same as a single write, but the response is so different I'm			//almost forced not to.			//in this instance also, resp is an array (not an object) of the bulk docs written						this.dispatchEvent( new CloudantEvent( CloudantEvent.WRITE_COMPLETE, resp, raw ) );						/*			if( resp.ok === false ) {				this.dispatchEvent( new CloudantEvent( CloudantEvent.WRITE_ERROR, resp, raw ) );			} else if( resp.ok === true ) {				doc._id = resp.id;				doc._rev = resp.rev;				this.dispatchEvent( new CloudantEvent( CloudantEvent.WRITE_COMPLETE, resp, raw ) );			}*/					}				private function onReadResponse( e:Event ):void {						var raw:String = e.target.data;			var resp:Object = JSON.parse( e.target.data );						trace( raw );						this.dispatchEvent( new CloudantEvent( CloudantEvent.READ_COMPLETE, resp, raw ) );					}				private function onQueryResponse( e:Event ):void {						var raw:String = e.target.data;			var resp:Object = JSON.parse( e.target.data );						trace( raw );						this.dispatchEvent( new CloudantEvent( CloudantEvent.QUERY_COMPLETE, resp, raw ) );					}				public function onIOError(e:IOErrorEvent):void {						var resp:Object = JSON.parse( e.target.data );						trace( "Cloudant Error: ", resp.error, ", ", resp.reason );			this.dispatchEvent( e );					}			}	}